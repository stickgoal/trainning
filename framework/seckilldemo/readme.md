# 高并发解决方案

以商品秒杀为基础演示如何处理高并发。

场景分析：
1. 短时超高访问量。进而导致高并发，又可能导致超卖
2. 秒杀商品数量有限，真正买到的人少，所以到数据库层面上读远超过写

传统玩法：

基于数据库，查询商品信息，创建订单，支付订单

性能瓶颈：
1. 带宽限制       =>  静态化+CDN（本文未涉及）
2. 服务器压力   =>  限流、使用缓存、MQ将压力转移到高性能的中间件
3. 数据库压力   =>  限制进入数据库的请求数量、MQ同步转异步，减少压力

PS 
CDN ： content delivery network  静态资源 （ html\css\js\图片）

解决方案：
原则：减少流量，限制流量、将服务器和数据库压力转移到高性能中间件

1. 客户端层透过js保护地址，在秒杀开始时再放开按钮，点击后禁用按钮一段时间，避免手工重复请求，减少流量
2. 使用缓存，解决读访问  => CDN静态资源、redis缓存，解决读需求
3. redis存储商品库存，预减库存（原子性），库存不足直接返回
4. 使用mq，异步化写入请求
5. 分布式session支持
6. 流控组件（本文未涉及）

 流程
 0. 秒杀开始前，加载商品数据到redis
 1. 用户第一次请求，页面渲染并缓存，后续页面不再渲染直接取缓存
 2. js控制用户按钮是否可点击，服务器时间为准，打开秒杀地址
 3. 用户请求进入后判断redis缓存是否足够不足够直接失败，预减商品库存
 4. MQ异步化处理请求
 5. 结果回执给用户

 

 ### 问题

 1. 实现redis预减操作，防止超卖

 预减本身可以使用decr命令，但是如果小于0就会超卖，所以需要先进行判断后再减，操作就变为
 ```bash
 [redis]获取库存
 [java]判断库存是否为0,若是结束，若否继续
 [redis]减少库存
 ```
 这三个操作我们要求是原子的，那么就需要使用上事务。
 但是Redis的所谓事务，本质是一个命令队列，一起发给redis-server之后，再批量执行，语法如下

 ```bash
 > multi  # 开始事务
 > del
 > set
 ...
 > exec  # 提交事务
 ```
 但是redis事务本身是无法保证隔离性的。也就是说，这批命令虽然会一起成功和失败，但是仍然可能与其他事务存在并发修改
这个时候就需要用上watch命令。watch会监测数据变化，如果在事务期间，数据发生了变化，则不会执行事务，也就是说一旦数据在外部被更改，就会回滚事务。

redisTemplate又有一个坑，就是事务必须在同一个连接，否则事务也不生效，所以可以看见

还有一个坑是，因为redis事务本质是个命令队列，所以中间的命令要到exec时才会执行，所以事务中的查询操作都只会返回null，
为此需要在事务前，watch后查询一下数据。

2.超卖问题的多重解决方案

- redis原子预减库存和检查，保证原子性的同时增强了性能
- rabbitmq异步处理，将并发串行
- 数据库加唯一索引，保证一个商品只会被卖一次